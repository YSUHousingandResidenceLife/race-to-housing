<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Race to Housing Board</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet">
  <style>
    html, body { height:100%; margin:0; }
    #map { position:absolute; inset:0; }
    .ui { position:absolute; top:12px; left:12px; z-index:10; display:flex; gap:8px; align-items:center; }
    .btn { background:#fff; border:1px solid #ddd; border-radius:8px; padding:8px 12px; font:14px system-ui; cursor:pointer; box-shadow:0 1px 4px rgba(0,0,0,.1) }
    .pill { background:#000; color:#fff; border-radius:999px; padding:6px 10px; font:12px system-ui; opacity:.85; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="ui">
    <button id="downloadBtn" class="btn">Download buildings (.geojson)</button>
    <span id="status" class="pill">Loading…</span>
  </div>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <script>
    // ===== CONFIG =====
    mapboxgl.accessToken = 'pk.eyJ1IjoieXN1LWhybCIsImEiOiJjbWZtcjVkNXUwNTJkMmxvaDZpaTF6b2x2In0.8-4W7BoAy5GmwM2_-L_Jzw';
    const STYLE_ID = 'mapbox://styles/ysu-hrl/cmfpr50qm00a401ry0uzb5b1q';
    const SAVED_URL = 'ysu_race_buildings_exact.geojson';
    const CAMPUS_BOUNDS = [[-80.6570, 41.1026], [-80.6415, 41.1120]];

    const TARGETS = [
      {name:'Lyden House',       color:'#FFD94A', coord:[-80.647458, 41.111143]},
      {name:'Cafaro House',      color:'#FF8A00', coord:[-80.6461376731338, 41.11100745921387]},
      {name:'Christman Dining',  color:'#808000', coord:[-80.64724052183561, 41.110525670257104]},
      {name:'Weller House',      color:'#00FFFF', coord:[-80.64483333333334, 41.10769444444445]},
      {name:'Wick House (Art)',  color:'#B67BFF', coord:[-80.64426251711262, 41.107489184836176]},
      {name:'Kilcawley House',   color:'#00A651', coord:[-80.64731987291158, 41.10673909169142]},
    ];

    const statusEl = document.getElementById('status');
    const downloadBtn = document.getElementById('downloadBtn');

    const map = new mapboxgl.Map({
      container: 'map',
      style: STYLE_ID,
      center: [-80.644685, 41.107524],
      zoom: 17.2,
      pitch: 60,
      bearing: -133.6,
      minZoom: 15,
      maxZoom: 19,
      maxBounds: CAMPUS_BOUNDS
    });

    map.addControl(new mapboxgl.NavigationControl(), 'top-right');

    // Helpers
    async function tryLoadSaved(url) {
      try {
        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) return null;
        const json = await r.json();
        if (!json || !json.features || !json.features.length) return null;
        return json;
      } catch { return null; }
    }
    function downloadJSON(obj, filename) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    }
    function hideLabelsAndBaseBuildings() {
      const layers = map.getStyle().layers || [];
      for (const lyr of layers) {
        if (lyr.type === 'symbol' || /label/i.test(lyr.id)) {
          try { map.setLayoutProperty(lyr.id, 'visibility', 'none'); } catch(e){}
        }
      }
      for (const lyr of layers) {
        if (/building/i.test(lyr.id) && (lyr.type === 'fill-extrusion' || lyr.type === 'fill')) {
          try { map.setLayoutProperty(lyr.id, 'visibility', 'none'); } catch(e){}
        }
      }
    }

    // Capture helpers using an explicit buildings source/layer
    function ensureCaptureLayer(){
      // Add streets vector source if missing
      if (!map.getSource('mbx-streets')) {
        map.addSource('mbx-streets', {
          type: 'vector',
          url: 'mapbox://mapbox.mapbox-streets-v8'
        });
      }
      // Add a nearly invisible building fill layer so features are "rendered"
      if (!map.getLayer('capture-buildings')) {
        map.addLayer({
          id: 'capture-buildings',
          type: 'fill',
          source: 'mbx-streets',
          'source-layer': 'building',
          paint: {
            'fill-color': 'rgba(0,0,0,0.001)'  // effectively invisible but renders
          }
        }, map.getStyle().layers[0]?.id); // insert low in stack
      }
    }
    function removeCaptureLayer(){
      if (map.getLayer('capture-buildings')) map.removeLayer('capture-buildings');
      if (map.getSource('mbx-streets')) map.removeSource('mbx-streets');
    }
    function queryBuildingAtScreenPoint(pointPx, paddings=[12,16,22,28]){
      for (const pad of paddings) {
        const bbox = [[pointPx.x - pad, pointPx.y - pad],[pointPx.x + pad, pointPx.y + pad]];
        const feats = map.queryRenderedFeatures(bbox, { layers: ['capture-buildings'] });
        // choose the "largest" polygon (more vertices)
        let best = null, bestScore = 0;
        for (const f of feats) {
          if (!f.geometry) continue;
          const g = f.geometry;
          const polys = g.type === 'Polygon' ? [g.coordinates] : g.type === 'MultiPolygon' ? g.coordinates : null;
          if (!polys) continue;
          let score = 0; for (const poly of polys) for (const ring of poly) score += ring.length;
          if (score > bestScore) { bestScore = score; best = g; }
        }
        if (best) return best;
      }
      return null;
    }

    map.on('load', async () => {
      // Prefer a saved file if present and non-empty
      let board = await tryLoadSaved(SAVED_URL);
      if (board) {
        statusEl.textContent = `Loaded ${board.features.length} saved features`;
      } else {
        statusEl.textContent = 'Capturing buildings…';
        // Add temp capture layer from streets v8
        ensureCaptureLayer();
        // make sure tiles are ready
        await new Promise(res => requestAnimationFrame(() => requestAnimationFrame(res)));

        board = { type:'FeatureCollection', features: [] };
        let captured = 0;

        for (const t of TARGETS) {
          const pt = map.project(t.coord);
          const geom = queryBuildingAtScreenPoint(pt);
          if (geom) {
            board.features.push({
              type:'Feature',
              properties:{ type:'building', name:t.name, fill:t.color, height:22 },
              geometry: geom
            });
            captured++;
          } else {
            console.warn('No footprint found for', t.name, 'at', t.coord);
          }
        }
        statusEl.textContent = `Captured ${captured}/${TARGETS.length}`;
        downloadBtn.onclick = () => downloadJSON(board, 'ysu_race_buildings_exact.geojson');
      }

      // Add your colored 3D buildings
      if (map.getSource('race')) map.removeSource('race');
      map.addSource('race', { type:'geojson', data: board });
      if (map.getLayer('race-buildings')) map.removeLayer('race-buildings');
      map.addLayer({
        id: 'race-buildings',
        type: 'fill-extrusion',
        source: 'race',
        paint: {
          'fill-extrusion-color': ['coalesce', ['get','fill'], '#d6001c'],
          'fill-extrusion-height': ['coalesce', ['get','height'], 22],
          'fill-extrusion-opacity': 0.96
        }
      });

      // Now clean up + hide labels/base buildings
      removeCaptureLayer();
      hideLabelsAndBaseBuildings();

      statusEl.textContent += ' — Done';
      map.on('error', e => { if (e && e.error) console.error('Mapbox error:', e.error); });
    });
  </script>
</body>
</html>
