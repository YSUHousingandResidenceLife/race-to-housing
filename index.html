<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Race to Housing — Draw Your Y + Ground Gaps</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
  <link href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.5.0/mapbox-gl-draw.css" rel="stylesheet" />
  <style>
    :root{ --card-bg:rgba(255,255,255,.96); --card-border:#e5e5e5; --accent:#d6001c; --muted:#6b7280; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #map{position:absolute;inset:0}

    .toolbar{
      position:absolute; left:50%; top:12px; transform:translateX(-50%); z-index:25;
      display:flex; gap:8px; background:var(--card-bg); border:1px solid var(--card-border);
      border-radius:12px; padding:8px; box-shadow:0 10px 25px rgba(0,0,0,.1)
    }
    .toolbar button{
      background:#fff; border:1px solid var(--card-border); border-radius:8px; padding:8px 10px;
      cursor:pointer; font-weight:600;
    }
    .toolbar .primary{ background:#d6001c; color:#fff; border-color:#c01a1a }
    .toolbar .ghost{ background:#fff }
    .toolbar .hint{ align-self:center; color:#384151; font-size:13px; padding:0 6px }

    .panel{position:absolute;top:12px;left:12px;z-index:20;width:360px;background:var(--card-bg);
      border:1px solid var(--card-border);border-radius:12px;box-shadow:0 10px 25px rgba(0,0,0,.1);
      overflow:hidden;display:flex;flex-direction:column}
    .panel header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--card-border);background:#fff}
    .panel header h3{margin:0;font-size:16px}
    .panel .content{padding:12px 14px;max-height:48vh;overflow:auto}
    .steps{display:grid;gap:10px}
    .step{display:grid;grid-template-columns:auto 1fr;gap:10px;align-items:flex-start;background:#fff;border:1px solid var(--card-border);border-radius:10px;padding:10px}
    .step .num{width:26px;height:26px;border-radius:50%;background:var(--accent);color:#fff;display:grid;place-items:center;font-weight:700;font-size:13px}
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Editor toolbar -->
  <div class="toolbar" id="toolbar">
    <button id="btnDraw" class="primary">Start / Resume Route</button>
    <button id="btnSave" class="ghost">Save Line</button>
    <button id="btnClearLine" class="ghost">Clear Line</button>
    <button id="btnApplyGaps" class="ghost">Apply Gaps</button>
    <button id="btnClearGaps" class="ghost">Clear Gaps</button>
    <div class="hint">Click to add points • drag to refine • double-click to end</div>
  </div>

  <!-- Quick instructions -->
  <section class="panel">
    <header><h3>Draw Your Y + Ground Gaps</h3></header>
    <div class="content">
      <div class="steps">
        <div class="step"><div class="num">1</div><div>Click <b>Start / Resume Route</b>, draw your Y on the ground (paths/plazas), double-click to finish.</div></div>
        <div class="step"><div class="num">2</div><div>Click <b>Apply Gaps</b> to hide buildings inside a buffered corridor around your Y.</div></div>
        <div class="step"><div class="num">3</div><div>If needed, click <b>Clear Gaps</b> to restore buildings. Use <b>Save Line</b> to download <code>route.geojson</code>.</div></div>
      </div>
    </div>
  </section>

  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.5.0/mapbox-gl-draw.js"></script>
  <!-- Turf for buffering -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script type="module">
    /************ CONFIG ************/
    const STYLE_ID   = 'mapbox://styles/ysu-hrl/cmfpr50qm00a401ry0uzb5b1q';
    const GEOJSON_URL= encodeURI('ysu_race_buildings_exact final.geojson');
    const CAMPUS_BOUNDS = [[-80.6570, 41.1026], [-80.6415, 41.1120]];
    const PITCH = 60, BEARING = -133.6;
    const CORRIDOR_WIDTH_M = 18; // change 14–24 to adjust “gap” width

    mapboxgl.accessToken = 'pk.eyJ1IjoieXN1LWhybCIsImEiOiJjbWZtcjVkNXUwNTJkMmxvaDZpaTF6b2x2In0.8-4W7BoAy5GmwM2_-L_Jzw';

    const map = new mapboxgl.Map({
      container: 'map',
      style: STYLE_ID,
      center: [-80.6458, 41.1090],
      zoom: 16.8,
      pitch: PITCH,
      bearing: BEARING,
      minZoom: 15,
      maxZoom: 19,
      maxBounds: CAMPUS_BOUNDS
    });
    map.addControl(new mapboxgl.NavigationControl(), 'top-right');

    function hideLabelsAndBaseBuildings() {
      const layers = map.getStyle().layers || [];
      for (const lyr of layers) {
        if (lyr.type === 'symbol' || /label/i.test(lyr.id)) {
          try { map.setLayoutProperty(lyr.id, 'visibility', 'none'); } catch(e){}
        }
      }
      for (const lyr of layers) {
        if (/building/i.test(lyr.id) && (lyr.type === 'fill-extrusion' || lyr.type === 'fill')) {
          try { map.setLayoutProperty(lyr.id, 'visibility', 'none'); } catch(e){}
        }
      }
    }

    async function loadJSON(url){ const r=await fetch(url,{cache:'no-store'}); if(!r.ok) throw new Error(url); return r.json(); }
    function bboxFromFeatures(fc){
      let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
      for(const f of fc.features||[]){ const g=f.geometry; if(!g) continue;
        const polys=g.type==='Polygon'?[g.coordinates]:g.type==='MultiPolygon'?g.coordinates:[];
        for(const poly of polys) for(const ring of poly) for(const [x,y] of ring){
          if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y;
        }}
      return [[minX,minY],[maxX,maxY]];
    }

    /************ DRAW (your line) ************/
    const Draw = new MapboxDraw({
      displayControlsDefault:false,
      controls:{ line_string:true, trash:true },
      defaultMode:'simple_select',
      styles:[
        { id:'gl-draw-polygon-and-line-vertex-halo-active', type:'circle',
          filter:['all',['==','meta','vertex'],['==','$type','Point'],['==','active','true']],
          paint:{'circle-radius':7,'circle-color':'#fff'}},
        { id:'gl-draw-polygon-and-line-vertex-active', type:'circle',
          filter:['all',['==','meta','vertex'],['==','$type','Point'],['==','active','true']],
          paint:{'circle-radius':5,'circle-color':'#d6001c'}},
        { id:'gl-draw-line', type:'line',
          filter:['all',['==','$type','LineString'],['!=','mode','static']],
          paint:{'line-color':'#d6001c','line-width':3}},
        { id:'gl-draw-line-static', type:'line',
          filter:['all',['==','$type','LineString'],['==','mode','static']],
          paint:{'line-color':'#d6001c','line-width':3}}
      ]
    });
    map.addControl(Draw, 'top-right');

    function startDraw(){
      map.doubleClickZoom.disable();
      Draw.changeMode('draw_line_string');
      map.getCanvas().style.cursor = 'crosshair';
    }
    map.on('draw.modechange', (e)=>{
      if (e.mode !== 'draw_line_string'){
        map.doubleClickZoom.enable();
        map.getCanvas().style.cursor = '';
      }
    });

    // Densify the line to ground-locked dots (no drift)
    function densify(line, spacing=2.8){
      const coords=line.geometry.coordinates;
      const R=6371000, toRad=d=>d*Math.PI/180;
      const H=(a,b)=>{const [x1,y1]=a,[x2,y2]=b,dl=toRad(y2-y1),dn=toRad(x2-x1);
        const s=Math.sin(dl/2)**2 + Math.cos(toRad(y1))*Math.cos(toRad(y2))*Math.sin(dn/2)**2;
        return 2*R*Math.asin(Math.sqrt(s));};
      const L=(a,b,t)=>[a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t];
      const pts=[]; let carry=0, iIdx=0;
      for(let i=0;i<coords.length-1;i++){
        const A=coords[i],B=coords[i+1], seg=H(A,B); let d=carry;
        while(d<=seg){ const t=d/seg; pts.push({type:'Feature',properties:{i:iIdx++},geometry:{type:'Point',coordinates:L(A,B,t)}}); d+=spacing; }
        carry=d-seg;
      }
      return {type:'FeatureCollection',features:pts};
    }

    function currentLines(){
      const fc = Draw.getAll();
      return fc.features.filter(f=>f.geometry?.type==='LineString');
    }

    function buildCorridorFC(lines){
      if (!lines.length) return {type:'FeatureCollection',features:[]};
      const merged = turf.lineMerge(turf.featureCollection(lines));
      const parts = merged.type==='Feature' ? [merged] : merged.features;
      const multi = turf.multiLineString(parts.map(f=>f.geometry.coordinates));
      const buff = turf.buffer(multi, CORRIDOR_WIDTH_M, {units:'meters'});
      return buff;
    }

    function syncFromDraw(){
      const lines = currentLines();

      // dots for the band
      const ptsAll = { type:'FeatureCollection', features:[] };
      for(const ln of lines) ptsAll.features.push(...densify(ln, 2.8).features);
      const ptsSrc = map.getSource('route-points-src');
      if (ptsSrc) ptsSrc.setData(ptsAll);

      // (don’t auto-build corridor here; only when you click Apply Gaps)
    }

    // Buttons
    document.getElementById('btnDraw').onclick = startDraw;

    document.getElementById('btnClearLine').onclick = ()=>{
      Draw.deleteAll();
      syncFromDraw();
      // also clear corridor & building mask
      map.getSource('y-corridor-src')?.setData({type:'FeatureCollection',features:[]});
      map.setFilter('race-buildings-masked', null);
      startDraw();
    };

    document.getElementById('btnSave').onclick = ()=>{
      const lines = currentLines();
      if (!lines.length){ alert('Draw your Y line first.'); return; }
      const out = { type:'FeatureCollection', features: lines };
      const a=document.createElement('a');
      a.href = URL.createObjectURL(new Blob([JSON.stringify(out,null,2)],{type:'application/json'}));
      a.download = 'route.geojson';
      a.click(); URL.revokeObjectURL(a.href);
    };

    document.getElementById('btnApplyGaps').onclick = ()=>{
      const lines = currentLines();
      if (!lines.length){ alert('Draw your Y line first.'); return; }
      const corridor = buildCorridorFC(lines);
      map.getSource('y-corridor-src')?.setData(corridor);
      // hide buildings that fall inside the corridor polygon
      const geom = corridor.geometry;
      map.setFilter('race-buildings-masked', ['!', ['within', ['literal', geom]]]);
    };

    document.getElementById('btnClearGaps').onclick = ()=>{
      map.getSource('y-corridor-src')?.setData({type:'FeatureCollection',features:[]});
      map.setFilter('race-buildings-masked', null);
    };

    /************ SOURCES & LAYERS ************/
    map.on('load', async () => {
      hideLabelsAndBaseBuildings();

      // Buildings (we’ll show them through a mask layer we control)
      const bldg = await loadJSON(GEOJSON_URL);
      map.addSource('race-buildings-src', { type:'geojson', data:bldg, generateId:true });

      // Masked buildings layer (we’ll filter it when gaps applied)
      map.addLayer({
        id:'race-buildings-masked',
        type:'fill-extrusion',
        source:'race-buildings-src',
        paint:{
          'fill-extrusion-color':['coalesce',['get','fill'],'#d6001c'],
          'fill-extrusion-height':['coalesce',['get','height'],22],
          'fill-extrusion-opacity':0.96
        }
      });

      // Route points & corridor sources (start empty)
      map.addSource('route-points-src', { type:'geojson', data:{type:'FeatureCollection',features:[]} });
      map.addSource('y-corridor-src',   { type:'geojson', data:{type:'FeatureCollection',features:[]} });

      // Ground-locked band as circles (never drifts), BELOW buildings
      const beforeId = 'race-buildings-masked';
      map.addLayer({
        id:'route-band',
        type:'circle',
        source:'route-points-src',
        layout:{ 'circle-pitch-alignment':'map', 'circle-sort-key': 0 },
        paint:{
          'circle-color':'#D62D20',
          'circle-radius':['interpolate',['linear'],['zoom'],14,5.5,16,7.5,18,9.0],
          'circle-opacity':0.95,
          'circle-pitch-scale':'map'
        }
      }, beforeId);

      // Corridor outline/fill (only visible after you click Apply Gaps)
      map.addLayer({
        id:'y-corridor-outline',
        type:'line',
        source:'y-corridor-src',
        layout:{ 'line-join':'round', 'line-cap':'round', 'line-pitch-alignment':'map' },
        paint:{
          'line-color':'#7A0E0E',
          'line-width':['interpolate',['linear'],['zoom'],14,4,16,6,18,8],
          'line-opacity':0.9
        }
      }, 'route-band');
      map.addLayer({
        id:'y-corridor-fill',
        type:'fill',
        source:'y-corridor-src',
        paint:{ 'fill-color':'#D62D20', 'fill-opacity':0.08 }
      }, 'y-corridor-outline');

      // Fit nicely on load
      const bounds = bboxFromFeatures(bldg);
      map.fitBounds(bounds, {
        padding:{ top:80, right:160, bottom:120, left:320 },
        maxZoom:18, pitch:PITCH, bearing:BEARING, duration:500
      });
      map.once('moveend', ()=> map.zoomTo(map.getZoom()+0.6,{duration:400}));

      // keep dots in sync while you draw/edit
      map.on('draw.create', syncFromDraw);
      map.on('draw.update', syncFromDraw);
      map.on('draw.delete', syncFromDraw);
    });
  </script>
</body>
</html>
