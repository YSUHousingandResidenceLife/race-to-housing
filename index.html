<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>YSU — Race to Housing Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet"/>
  <style>
    html, body, #map { height: 100%; margin: 0 }
    .hud {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      background: #0b0c10cc; color: #e5e7eb; padding: 8px 10px; border-radius: 10px;
      font: 14px system-ui, sans-serif;
    }
    .penguin {
      font-size: 28px; line-height: 28px;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="hud">drag to pan · wheel to zoom · <b>[</b>/<b>]</b> move penguin</div>

  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoieXN1LWhybCIsImEiOiJjbWZtcjVkNXUwNTJkMmxvaDZpaTF6b2x2In0.8-4W7BoAy5GmwM2_-L_Jzw';

    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11', // you can swap in your custom YSU style ID later
      center: [-80.6498, 41.1079], 
      zoom: 15
    });

    const ROUTE_URL = 'data/route.geojson';

    async function loadJSON(url) {
      const r = await fetch(url);
      if (!r.ok) throw new Error(url + ' failed');
      return r.json();
    }

    function collectRouteLngLats(features) {
      const out = [];
      for (const f of features) {
        const g = f.geometry || {};
        if (g.type === 'LineString') {
          out.push(...g.coordinates);
        } else if (g.type === 'MultiLineString') {
          g.coordinates.forEach(seg => out.push(...seg));
        }
      }
      return out;
    }

    map.on('load', async () => {
      let gj;
      try {
        gj = await loadJSON(ROUTE_URL);
      } catch (e) {
        alert('Could not load GeoJSON: ' + e.message);
        return;
      }

      const features = (gj.type === 'FeatureCollection') ? gj.features : [gj];

      const polys = features.filter(f => {
        const t = f.geometry && f.geometry.type;
        return t === 'Polygon' || t === 'MultiPolygon';
      });
      const lines = features.filter(f => {
        const t = f.geometry && f.geometry.type;
        return t === 'LineString' || t === 'MultiLineString';
      });

      if (polys.length) {
        map.addSource('polys', { type: 'geojson', data: { type:'FeatureCollection', features: polys } });
        map.addLayer({
          id: 'polys-fill',
          type: 'fill',
          source: 'polys',
          paint: { 'fill-color': '#ff3344', 'fill-opacity': 0.3 }
        });
        map.addLayer({
          id: 'polys-outline',
          type: 'line',
          source: 'polys',
          paint: { 'line-color': '#111', 'line-width': 2 }
        });
      }

      if (lines.length) {
        map.addSource('lines', { type: 'geojson', data: { type:'FeatureCollection', features: lines } });
        map.addLayer({
          id: 'route-line',
          type: 'line',
          source: 'lines',
          paint: { 'line-color': '#ff3344', 'line-width': 5 }
        });
      }

      const bounds = new mapboxgl.LngLatBounds();
      features.forEach(f => {
        const g = f.geometry;
        if (!g) return;
        if (g.type === 'Polygon') g.coordinates.flat().forEach(c => bounds.extend(c));
        if (g.type === 'MultiPolygon') g.coordinates.flat(2).forEach(c => bounds.extend(c));
        if (g.type === 'LineString') g.coordinates.forEach(c => bounds.extend(c));
        if (g.type === 'MultiLineString') g.coordinates.flat().forEach(c => bounds.extend(c));
      });
      if (!bounds.isEmpty()) map.fitBounds(bounds, { padding: 80, maxZoom: 18 });

      const routeCoords = collectRouteLngLats(lines);
      let idx = 0;

      const penguinEl = document.createElement('div');
      penguinEl.className = 'penguin';
      penguinEl.textContent = '🐧';

      const penguin = new mapboxgl.Marker({ element: penguinEl })
        .setLngLat(routeCoords.length ? routeCoords[0] : map.getCenter().toArray())
        .addTo(map);

      function updatePenguin() {
        if (!routeCoords.length) return;
        idx = Math.max(0, Math.min(idx, routeCoords.length - 1));
        penguin.setLngLat(routeCoords[idx]);
      }

      window.addEventListener('keydown', (e) => {
        if (!routeCoords.length) return;
        if (e.key === ']') { idx++; updatePenguin(); }
        if (e.key === '[') { idx--; updatePenguin(); }
      });
    });
  </script>
</body>
</html>
