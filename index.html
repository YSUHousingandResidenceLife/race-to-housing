<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Campus Route ‚Äî No Key (Leaflet + OSM)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  html, body, #map { height: 100%; margin: 0; }
  .legend { position: fixed; left: 10px; top: 10px; background: #0b0c10cc; color: #e5e7eb; padding: 8px 10px; border-radius: 8px; font: 14px system-ui; z-index: 999; }
  .penguin-icon {
    font-size: 28px; line-height: 28px;
    transform: translate(-50%, -50%); /* center on point */
  }
</style>
</head>
<body>
<div id="map"></div>
<div class="legend">Drag to pan ¬∑ wheel to zoom ¬∑ <b>]</b> forward ¬∑ <b>[</b> back</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
(async function(){
  // ===== CONFIG =====
  // Put your GeoJSON file in the repo (recommend: data/route.geojson).
  // If your current file is "route (3).geojson", rename it to "route.geojson" to avoid space issues.
  const GEOJSON_URL = 'data/route.geojson'; // change if needed

  // Route style (black/red theme)
  const routeStyle = {
    color: '#ff3344',
    weight: 5,
    opacity: 0.95
  };

  // Polygon (building) style
  const polygonStyle = {
    color: '#111', weight: 2, opacity: 1,
    fillColor: '#ff3344', fillOpacity: 0.30
  };

  // ===== MAP (no API key) =====
  const map = L.map('map', {
    zoomControl: true, attributionControl: true
  });

  // Free tiles (no token)
  const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 20,
    attribution: '&copy; OpenStreetMap'
  }).addTo(map);

  // ===== LOAD YOUR GEOJSON =====
  let gj;
  try {
    const res = await fetch(GEOJSON_URL);
    if (!res.ok) throw new Error('fetch failed: ' + GEOJSON_URL);
    gj = await res.json();
  } catch (e) {
    alert('Could not load GeoJSON: ' + e.message);
    return;
  }

  // Normalize: accept Feature or FeatureCollection
  const features = (gj.type === 'FeatureCollection') ? gj.features : [gj];

  // Separate routes (LineString/MultiLineString) and polygons
  const lines = [];
  const polys = [];
  for (const f of features) {
    const t = f.geometry && f.geometry.type;
    if (t === 'LineString' || t === 'MultiLineString') lines.push(f);
    if (t === 'Polygon'    || t === 'MultiPolygon')    polys.push(f);
  }

  // Draw polygons (buildings) if present
  let polyLayer = null, lineLayer = null;
  if (polys.length) {
    polyLayer = L.geoJSON({ type:'FeatureCollection', features: polys }, {
      style: polygonStyle
    }).addTo(map);
  }

  // Draw route(s)
  if (lines.length) {
    lineLayer = L.geoJSON({ type:'FeatureCollection', features: lines }, {
      style: routeStyle
    }).addTo(map);
  }

  // Fit bounds to whatever we have
  const group = L.featureGroup([polyLayer, lineLayer].filter(Boolean));
  if (group.getLayers().length) {
    map.fitBounds(group.getBounds().pad(0.2));
  } else {
    // fallback: center on YSU-ish area
    map.setView([41.103, -80.647], 15);
  }

  // ===== PENGUIN TOKEN ALONG ROUTE =====
  // Extract a single array of route coordinates (lng,lat ‚Üí lat,lng)
  function collectRouteLatLngs() {
    const latlngs = [];
    for (const f of lines) {
      const g = f.geometry;
      if (g.type === 'LineString') {
        g.coordinates.forEach(([lng,lat]) => latlngs.push([lat,lng]));
      } else if (g.type === 'MultiLineString') {
        g.coordinates.forEach(seg => seg.forEach(([lng,lat]) => latlngs.push([lat,lng])));
      }
    }
    return latlngs;
  }

  const pathLatLngs = collectRouteLatLngs();
  if (!pathLatLngs.length) {
    console.warn('No LineString found. If you only have polygons, the penguin will not move.');
  }

  // Penguin as a DivIcon so we can use emoji without image files
  const penguinIcon = L.divIcon({
    className: 'penguin-icon',
    html: 'üêß'
  });

  let idx = 0;
  const penguin = pathLatLngs.length
    ? L.marker(pathLatLngs[0], { icon: penguinIcon }).addTo(map)
    : null;

  function updatePenguin() {
    if (!penguin || !pathLatLngs.length) return;
    idx = Math.max(0, Math.min(idx, pathLatLngs.length - 1));
    penguin.setLatLng(pathLatLngs[idx]);
  }
  updatePenguin();

  // Keyboard controls to test progress (we‚Äôll wire to Firestore later)
  window.addEventListener('keydown', (e) => {
    if (!pathLatLngs.length) return;
    if (e.key === ']') { idx++; updatePenguin(); }
    if (e.key === '[') { idx--; updatePenguin(); }
  });

  // ===== COMMON ‚Äúno building polygon‚Äù CAUSES (and how this page avoids them) =====
  // - If you have a building footprint: geometry.type MUST be "Polygon" (or MultiPolygon),
  //   coordinates are arrays of [lng, lat], outer ring CLOSED (first==last), at least 4 points.
  // - Routes should be LineString/MultiLineString; this page draws them as a red line automatically.
  // - This page will happily show BOTH: polygons (as tinted fills) AND your red route.

})();
</script>
</body>
</html>
